#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage:
  release-zed-extension.sh --tag vX.Y.Z [--dry-run] [--bump-version]
  release-zed-extension.sh vX.Y.Z [--dry-run] [--bump-version]

Modes:
  - Release mode (default): verifies repository state and publishes tag + GitHub release.
  - Bump mode (--bump-version): updates extension.toml, Cargo.toml, and Cargo.lock to match tag version,
    then exits so you can commit/push before release.

Checks (release mode):
  - Current branch is master
  - Worktree is clean
  - Upstream is origin/master and fully synced
  - extension.toml/Cargo.toml/Cargo.lock versions are identical and match tag
  - Tag does not already exist locally/remotely

Actions (release mode):
  - Create annotated tag
  - Push tag to origin
  - Create GitHub release with autogenerated notes
USAGE
}

fail() {
  echo "Error: $*" >&2
  exit 1
}

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || fail "required command not found: $1"
}

print_cmd() {
  printf '+'
  for arg in "$@"; do
    printf ' %q' "$arg"
  done
  printf '\n'
}

run_or_print() {
  if [[ "$DRY_RUN" == "1" ]]; then
    print_cmd "$@"
  else
    "$@"
  fi
}

read_version_from_toml() {
  local file="$1"
  awk -F '"' '/^version = "/ { print $2; exit }' "$file"
}

read_package_name_from_cargo_toml() {
  awk -F '"' '
    BEGIN { in_pkg = 0 }
    /^\[package\]$/ { in_pkg = 1; next }
    /^\[/ { if (in_pkg) exit }
    in_pkg && /^name = "/ { print $2; exit }
  ' Cargo.toml
}

read_version_from_cargo_lock() {
  local package_name="$1"
  awk -v package_name="$package_name" '
    BEGIN { in_pkg = 0; found = 0 }
    /^\[\[package\]\]$/ { in_pkg = 1; pkg = ""; next }
    in_pkg && /^name = "/ {
      if ($0 == "name = \"" package_name "\"") {
        pkg = package_name
      }
      next
    }
    in_pkg && pkg == package_name && /^version = "/ {
      gsub(/^version = "/, "");
      gsub(/"$/, "");
      print;
      found = 1;
      exit
    }
    END { if (found == 0) exit 2 }
  ' Cargo.lock
}

write_version_to_toml() {
  local file="$1"
  local version="$2"
  local tmp
  tmp="$(mktemp)"

  awk -v version="$version" '
    BEGIN { updated = 0 }
    {
      if (!updated && $0 ~ /^version = "/) {
        print "version = \"" version "\""
        updated = 1
      } else {
        print
      }
    }
    END {
      if (!updated) {
        exit 2
      }
    }
  ' "$file" >"$tmp" || {
    rm -f "$tmp"
    fail "failed to update version in $file"
  }

  mv "$tmp" "$file"
}

write_version_to_cargo_lock() {
  local package_name="$1"
  local version="$2"
  local tmp
  tmp="$(mktemp)"

  awk -v package_name="$package_name" -v version="$version" '
    BEGIN { in_pkg = 0; pkg = ""; updated = 0 }
    /^\[\[package\]\]$/ { in_pkg = 1; pkg = ""; print; next }
    in_pkg && /^name = "/ {
      if ($0 == "name = \"" package_name "\"") {
        pkg = package_name
      }
      print
      next
    }
    in_pkg && pkg == package_name && /^version = "/ && updated == 0 {
      print "version = \"" version "\""
      updated = 1
      pkg = ""
      next
    }
    { print }
    END { if (!updated) exit 2 }
  ' Cargo.lock >"$tmp" || {
    rm -f "$tmp"
    fail "failed to update package '$package_name' version in Cargo.lock"
  }

  mv "$tmp" Cargo.lock
}

TAG=""
DRY_RUN="0"
BUMP_VERSION="0"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --tag)
      [[ $# -ge 2 ]] || fail "--tag requires a value"
      TAG="$2"
      shift 2
      ;;
    --dry-run)
      DRY_RUN="1"
      shift
      ;;
    --bump-version)
      BUMP_VERSION="1"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      if [[ -z "$TAG" ]]; then
        TAG="$1"
        shift
      else
        fail "unexpected argument: $1"
      fi
      ;;
  esac
done

[[ -n "$TAG" ]] || {
  usage
  fail "missing tag"
}

[[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+([-.][0-9A-Za-z.-]+)?$ ]] || {
  fail "tag must look like vX.Y.Z (got: $TAG)"
}

RELEASE_VERSION="${TAG#v}"

require_cmd git
require_cmd gh

git rev-parse --git-dir >/dev/null 2>&1 || fail "current directory is not a git repository"

[[ -f extension.toml ]] || fail "extension.toml not found in repo root"
[[ -f Cargo.toml ]] || fail "Cargo.toml not found in repo root"
[[ -f Cargo.lock ]] || fail "Cargo.lock not found in repo root"

cargo_package_name="$(read_package_name_from_cargo_toml)"
[[ -n "$cargo_package_name" ]] || fail "could not read package name from Cargo.toml"

current_branch="$(git branch --show-current)"
[[ "$current_branch" == "master" ]] || fail "current branch is '$current_branch'; expected 'master'"

[[ -z "$(git status --porcelain)" ]] || fail "worktree is not clean"

if [[ "$BUMP_VERSION" == "1" ]]; then
  if [[ "$DRY_RUN" == "1" ]]; then
    print_cmd write_version_to_toml extension.toml "$RELEASE_VERSION"
    print_cmd write_version_to_toml Cargo.toml "$RELEASE_VERSION"
    print_cmd write_version_to_cargo_lock "$cargo_package_name" "$RELEASE_VERSION"
    print_cmd cargo check
  else
    write_version_to_toml extension.toml "$RELEASE_VERSION"
    write_version_to_toml Cargo.toml "$RELEASE_VERSION"
    write_version_to_cargo_lock "$cargo_package_name" "$RELEASE_VERSION"
    cargo check >/dev/null
  fi

  echo "Version files updated to $RELEASE_VERSION"
  echo "Commit and push these changes, then rerun without --bump-version to publish $TAG"
  exit 0
fi

upstream_ref="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
[[ -n "$upstream_ref" ]] || fail "no upstream configured for master"
[[ "$upstream_ref" == "origin/master" ]] || fail "upstream is '$upstream_ref'; expected 'origin/master'"

git fetch origin master --tags >/dev/null 2>&1 || fail "failed to fetch origin/master and tags"

read -r ahead behind <<<"$(git rev-list --left-right --count HEAD...@{u})"
[[ "$ahead" == "0" ]] || fail "local master is ahead of origin/master by $ahead commit(s); push first"
[[ "$behind" == "0" ]] || fail "local master is behind origin/master by $behind commit(s); pull first"

extension_version="$(read_version_from_toml extension.toml)"
[[ -n "$extension_version" ]] || fail "could not read version from extension.toml"

cargo_version="$(read_version_from_toml Cargo.toml)"
[[ -n "$cargo_version" ]] || fail "could not read version from Cargo.toml"

cargo_lock_version="$(read_version_from_cargo_lock "$cargo_package_name")" || fail "could not read package '$cargo_package_name' version from Cargo.lock"

[[ "$extension_version" == "$cargo_version" ]] || {
  fail "version mismatch: extension.toml=$extension_version Cargo.toml=$cargo_version (run with --bump-version)"
}

[[ "$extension_version" == "$cargo_lock_version" ]] || {
  fail "version mismatch: extension.toml=$extension_version Cargo.lock=$cargo_lock_version (run with --bump-version)"
}

[[ "$extension_version" == "$RELEASE_VERSION" ]] || {
  fail "tag '$TAG' does not match current version '$extension_version' (run with --bump-version)"
}

git rev-parse -q --verify "refs/tags/$TAG" >/dev/null 2>&1 && fail "tag already exists locally: $TAG"
remote_tag_count="$(git ls-remote --tags origin "refs/tags/$TAG" | wc -l | tr -d ' ')"
[[ "$remote_tag_count" == "0" ]] || fail "tag already exists on origin: $TAG"

if [[ "$DRY_RUN" != "1" ]]; then
  gh auth status >/dev/null 2>&1 || fail "gh is not authenticated"
  gh release view "$TAG" >/dev/null 2>&1 && fail "GitHub release already exists for $TAG"
fi

run_or_print git tag -a "$TAG" -m "Release $TAG"
run_or_print git push origin "$TAG"
run_or_print gh release create "$TAG" --verify-tag --generate-notes --title "$TAG"

echo "Release flow completed for $TAG"
